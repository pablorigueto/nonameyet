diff --git a/core/core.services.yml b/core/core.services.yml
index 07def88bc5..b8e48224c5 100644
--- a/core/core.services.yml
+++ b/core/core.services.yml
@@ -1222,6 +1222,11 @@ services:
     tags:
       - { name: access_check, applies_to: _csrf_token, needs_incoming_request: TRUE }
     arguments: ['@csrf_token']
+  access_check.csrf_ajax:
+    class: Drupal\Core\Access\CsrfAjaxAccessCheck
+    tags:
+      - { name: access_check, applies_to: _csrf_ajax_token, needs_incoming_request: TRUE }
+    arguments: ['@csrf_token']
   access_check.header.csrf:
     class: Drupal\Core\Access\CsrfRequestHeaderAccessCheck
     arguments: ['@session_configuration', '@csrf_token']
@@ -1367,6 +1372,11 @@ services:
     tags:
       - { name: route_processor_outbound }
     arguments: ['@csrf_token']
+  route_processor_csrf_ajax:
+    class: Drupal\Core\Access\RouteProcessorCsrfAjax
+    tags:
+      - { name: route_processor_outbound }
+    arguments: ['@csrf_token']
   transliteration:
     class: Drupal\Core\Transliteration\PhpTransliteration
     arguments: [null, '@module_handler']
diff --git a/core/lib/Drupal/Core/Access/CsrfAccessCheck.php b/core/lib/Drupal/Core/Access/CsrfAccessCheck.php
index 48e75acb58..cce5c40c8a 100644
--- a/core/lib/Drupal/Core/Access/CsrfAccessCheck.php
+++ b/core/lib/Drupal/Core/Access/CsrfAccessCheck.php
@@ -4,6 +4,7 @@
 
 use Drupal\Core\Routing\Access\AccessInterface as RoutingAccessInterface;
 use Drupal\Core\Routing\RouteMatchInterface;
+use Symfony\Component\HttpFoundation\ParameterBag;
 use Symfony\Component\Routing\Route;
 use Symfony\Component\HttpFoundation\Request;
 
@@ -48,11 +49,10 @@ public function __construct(CsrfTokenGenerator $csrf_token) {
    */
   public function access(Route $route, Request $request, RouteMatchInterface $route_match) {
     $parameters = $route_match->getRawParameters();
-    $path = ltrim($route->getPath(), '/');
-    // Replace the path parameters with values from the parameters array.
-    foreach ($parameters as $param => $value) {
-      $path = str_replace("{{$param}}", $value, $path);
+    if ($parameters instanceof ParameterBag) {
+      $parameters = $parameters->all();
     }
+    $path = RouteProcessorCsrf::preparePath($route, $parameters);
 
     if ($this->csrfToken->validate($request->query->get('token', ''), $path)) {
       $result = AccessResult::allowed();
diff --git a/core/lib/Drupal/Core/Access/CsrfAjaxAccessCheck.php b/core/lib/Drupal/Core/Access/CsrfAjaxAccessCheck.php
new file mode 100644
index 0000000000..bb8313feb8
--- /dev/null
+++ b/core/lib/Drupal/Core/Access/CsrfAjaxAccessCheck.php
@@ -0,0 +1,40 @@
+<?php
+
+namespace Drupal\Core\Access;
+
+use Drupal\Core\Routing\Access\AccessInterface as RoutingAccessInterface;
+use Drupal\Core\Routing\RouteMatchInterface;
+use Symfony\Component\HttpFoundation\ParameterBag;
+use Symfony\Component\Routing\Route;
+use Symfony\Component\HttpFoundation\Request;
+
+/**
+ * Allows access to routes to be controlled by a '_csrf_token' parameter.
+ *
+ * To use this check, add a "token" GET parameter to URLs of which the value is
+ * a token generated by \Drupal::csrfToken()->get() using the same value as the
+ * "_csrf_token" parameter in the route.
+ */
+class CsrfAjaxAccessCheck extends CsrfAccessCheck implements RoutingAccessInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function access(Route $route, Request $request, RouteMatchInterface $route_match) {
+    $parameters = $route_match->getRawParameters();
+    if ($parameters instanceof ParameterBag) {
+      $parameters = $parameters->all();
+    }
+    $path = RouteProcessorCsrfAjax::preparePath($route, $parameters);
+
+    if ($this->csrfToken->validate($request->query->get('token', ''), $path)) {
+      $result = AccessResult::allowed();
+    }
+    else {
+      $result = AccessResult::forbidden($request->query->has('token') ? "'csrf_ajax_token' URL query argument is invalid." : "'csrf_ajax_token' URL query argument is missing.");
+    }
+    // Not cacheable because the CSRF token is highly dynamic.
+    return $result->setCacheMaxAge(0);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Access/RouteProcessorCsrf.php b/core/lib/Drupal/Core/Access/RouteProcessorCsrf.php
index d0aec30185..48cc0c7e37 100644
--- a/core/lib/Drupal/Core/Access/RouteProcessorCsrf.php
+++ b/core/lib/Drupal/Core/Access/RouteProcessorCsrf.php
@@ -35,11 +35,7 @@ public function __construct(CsrfTokenGenerator $csrf_token) {
    */
   public function processOutbound($route_name, Route $route, array &$parameters, BubbleableMetadata $bubbleable_metadata = NULL) {
     if ($route->hasRequirement('_csrf_token')) {
-      $path = ltrim($route->getPath(), '/');
-      // Replace the path parameters with values from the parameters array.
-      foreach ($parameters as $param => $value) {
-        $path = str_replace("{{$param}}", $value, $path);
-      }
+      $path = static::preparePath($route, $parameters);
       // Adding this to the parameters means it will get merged into the query
       // string when the route is compiled.
       if (!$bubbleable_metadata) {
@@ -61,6 +57,36 @@ public function processOutbound($route_name, Route $route, array &$parameters, B
     }
   }
 
+  /**
+   * Prepares the route's path for generating a token.
+   *
+   * @param \Symfony\Component\Routing\Route $route
+   *   The outbound route to process.
+   * @param array $parameters
+   *   An array of parameters to be passed to the route compiler. Passed by
+   *   reference.
+   *
+   * @return string
+   *   The route's path with parameters replaced.
+   */
+  public static function preparePath(Route $route, array &$parameters) {
+    $path = ltrim($route->getPath(), '/');
+    $exclude_parameters = [];
+    if ($route->getOption('_csrf_exclude_parameters')) {
+      $exclude_parameters = $route->getOption('_csrf_exclude_parameters');
+    }
+    // Replace the path parameters with values from the parameters array.
+    foreach ($parameters as $param => $value) {
+      // Do not replace this parameter if it should not be used in the token.
+      if (in_array($param, $exclude_parameters)) {
+        continue;
+      }
+      $path = str_replace("{{$param}}", $value, $path);
+    }
+
+    return $path;
+  }
+
   /**
    * #lazy_builder callback; gets a CSRF token for the given path.
    *
diff --git a/core/lib/Drupal/Core/Access/RouteProcessorCsrfAjax.php b/core/lib/Drupal/Core/Access/RouteProcessorCsrfAjax.php
new file mode 100644
index 0000000000..448838a912
--- /dev/null
+++ b/core/lib/Drupal/Core/Access/RouteProcessorCsrfAjax.php
@@ -0,0 +1,73 @@
+<?php
+
+namespace Drupal\Core\Access;
+
+use Drupal\Component\Utility\Crypt;
+use Drupal\Core\Render\BubbleableMetadata;
+use Drupal\Core\RouteProcessor\OutboundRouteProcessorInterface;
+use Symfony\Component\Routing\Route;
+
+/**
+ * Processes outbound ajax/nojs route to handle the CSRF token.
+ */
+class RouteProcessorCsrfAjax extends RouteProcessorCsrf implements OutboundRouteProcessorInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function processOutbound($route_name, Route $route, array &$parameters, BubbleableMetadata $bubbleable_metadata = NULL) {
+    if ($route->hasRequirement('_csrf_ajax_token')) {
+      $path = static::preparePath($route, $parameters);
+      // Adding this to the parameters means it will get merged into the query
+      // string when the route is compiled.
+      if (!$bubbleable_metadata) {
+        $parameters['token'] = $this->csrfToken->get($path);
+      }
+      else {
+        // Generate a placeholder and a render array to replace it.
+        $placeholder = Crypt::hashBase64($path);
+        $placeholder_render_array = [
+          '#lazy_builder' => ['route_processor_csrf_ajax:renderPlaceholderCsrfToken', [$path]],
+        ];
+
+        // Instead of setting an actual CSRF token as the query string, we set
+        // the placeholder, which will be replaced at the very last moment. This
+        // ensures links with CSRF tokens don't break cacheability.
+        $parameters['token'] = $placeholder;
+        $bubbleable_metadata->addAttachments(['placeholders' => [$placeholder => $placeholder_render_array]]);
+      }
+    }
+  }
+
+  /**
+   * Prepares the route's path for generating a token.
+   *
+   * @param \Symfony\Component\Routing\Route $route
+   *   The outbound route to process.
+   * @param array $parameters
+   *   An array of parameters to be passed to the route compiler. Passed by
+   *   reference.
+   *
+   * @return string
+   *   The route's path with parameters replaced, except for the 'js' parameter.
+   */
+  public static function preparePath(Route $route, array &$parameters) {
+    $replacements = $parameters;
+    if (isset($replacements['js']) && in_array($replacements['js'], ['ajax', 'nojs'])) {
+      unset($replacements['js']);
+    }
+    $keys = array_map(
+      function ($key) {
+        return "{{$key}}";
+      },
+      array_keys($replacements)
+    );
+
+    // Replace the path parameters with values from the parameters array.
+    $path = ltrim($route->getPath(), '/');
+    $path = str_replace($keys, $replacements, $path);
+
+    return $path;
+  }
+
+}
diff --git a/core/modules/views_ui/views_ui.module b/core/modules/views_ui/views_ui.module
index 04c07663e2..b30f879b65 100644
--- a/core/modules/views_ui/views_ui.module
+++ b/core/modules/views_ui/views_ui.module
@@ -50,8 +50,8 @@ function views_ui_entity_type_build(array &$entity_types) {
     ->setLinkTemplate('preview-form', '/admin/structure/views/view/{view}/preview/{display_id}')
     ->setLinkTemplate('duplicate-form', '/admin/structure/views/view/{view}/duplicate')
     ->setLinkTemplate('delete-form', '/admin/structure/views/view/{view}/delete')
-    ->setLinkTemplate('enable', '/admin/structure/views/view/{view}/enable')
-    ->setLinkTemplate('disable', '/admin/structure/views/view/{view}/disable')
+    ->setLinkTemplate('enable', '/admin/structure/views/view/{view}/enable/{js}')
+    ->setLinkTemplate('disable', '/admin/structure/views/view/{view}/disable/{js}')
     ->setLinkTemplate('break-lock-form', '/admin/structure/views/view/{view}/break-lock')
     ->setLinkTemplate('collection', '/admin/structure/views');
 }
diff --git a/core/modules/views_ui/views_ui.routing.yml b/core/modules/views_ui/views_ui.routing.yml
index 03360b06bd..dae6fc5759 100644
--- a/core/modules/views_ui/views_ui.routing.yml
+++ b/core/modules/views_ui/views_ui.routing.yml
@@ -47,22 +47,26 @@ views_ui.reports_plugins:
     _permission: 'administer views'
 
 entity.view.enable:
-  path: '/admin/structure/views/view/{view}/enable'
+  path: '/admin/structure/views/view/{view}/enable/{js}'
   defaults:
     _controller: '\Drupal\views_ui\Controller\ViewsUIController::ajaxOperation'
     op: enable
+    js: 'ajax'
   requirements:
     _entity_access: view.enable
-    _csrf_token: 'TRUE'
+    _csrf_ajax_token: 'TRUE'
+    js: 'nojs|ajax'
 
 entity.view.disable:
-  path: '/admin/structure/views/view/{view}/disable'
+  path: '/admin/structure/views/view/{view}/disable/{js}'
   defaults:
     _controller: '\Drupal\views_ui\Controller\ViewsUIController::ajaxOperation'
     op: disable
+    js: 'ajax'
   requirements:
     _entity_access: view.disable
-    _csrf_token: 'TRUE'
+    _csrf_ajax_token: 'TRUE'
+    js: 'nojs|ajax'
 
 entity.view.duplicate_form:
   path: '/admin/structure/views/view/{view}/duplicate'
diff --git a/core/tests/Drupal/Tests/Core/Access/RouteProcessorCsrfAjaxTest.php b/core/tests/Drupal/Tests/Core/Access/RouteProcessorCsrfAjaxTest.php
new file mode 100644
index 0000000000..57ba59269f
--- /dev/null
+++ b/core/tests/Drupal/Tests/Core/Access/RouteProcessorCsrfAjaxTest.php
@@ -0,0 +1,61 @@
+<?php
+
+namespace Drupal\Tests\Core\Access;
+
+use Drupal\Component\Utility\Crypt;
+use Drupal\Core\Render\BubbleableMetadata;
+use Drupal\Tests\UnitTestCase;
+use Drupal\Core\Access\RouteProcessorCsrfAjax;
+use Symfony\Component\Routing\Route;
+
+/**
+ * @coversDefaultClass \Drupal\Core\Access\RouteProcessorCsrfAjax
+ * @group Access
+ */
+class RouteProcessorCsrfAjaxTest extends UnitTestCase {
+
+  /**
+   * The mock CSRF token generator.
+   *
+   * @var \Drupal\Core\Access\CsrfTokenGenerator|\PHPUnit_Framework_MockObject_MockObject
+   */
+  protected $csrfToken;
+
+  /**
+   * The route processor.
+   *
+   * @var \Drupal\Core\Access\RouteProcessorCsrfAjax
+   */
+  protected $processor;
+
+  protected function setUp(): void {
+    $this->csrfToken = $this->getMockBuilder('Drupal\Core\Access\CsrfTokenGenerator')
+      ->disableOriginalConstructor()
+      ->getMock();
+
+    $this->processor = new RouteProcessorCsrfAjax($this->csrfToken);
+  }
+
+  /**
+   * Tests the processOutbound() method with CSRF token for ajax/nojs routes.
+   */
+  public function testProcessOutboundTokenAjax() {
+    $route = new Route('/test-path/{js}', [], ['_csrf_ajax_token' => 'TRUE']);
+    $parameters = ['js' => 'nojs'];
+
+    $bubbleable_metadata = new BubbleableMetadata();
+    $this->processor->processOutbound('test', $route, $parameters, $bubbleable_metadata);
+    // 'token' should be added to the parameters array.
+    $this->assertArrayHasKey('token', $parameters);
+    // Bubbleable metadata of routes with a _csrf_ajax_token route requirement
+    // is a placeholder.
+    $path = 'test-path/{js}';
+    $placeholder = Crypt::hashBase64($path);
+    $placeholder_render_array = [
+      '#lazy_builder' => ['route_processor_csrf_ajax:renderPlaceholderCsrfToken', [$path]],
+    ];
+    $this->assertSame($parameters['token'], $placeholder);
+    $this->assertEquals((new BubbleableMetadata())->setAttachments(['placeholders' => [$placeholder => $placeholder_render_array]]), $bubbleable_metadata);
+  }
+
+}
