<?php

/**
 * @file
 * Contains find_checkin.
 */

use Drupal\comment\CommentInterface;
use Drupal\Component\Render\PlainTextOutput;
use Drupal\Component\Utility\Html;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\node\NodeInterface;
use Drupal\user\Entity\User;
use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\Core\Render\Markup;

/**
 * Implements hook_page_attachments().
 */
function find_checkin_page_attachments(array &$attachments) {
  if (!\Drupal::service('router.admin_context')->isAdminRoute()) {
    $attachments['#attached']['library'][] = 'find_checkin/find-checkin-styling';
  }
}

/**
 * Set summary and title using the others fields.
 * Fillout automatically the full address and coordinate fields.
 */
function find_checkin_node_presave(NodeInterface $node) {
  // && $node->isNew()
  if ($node->getType() == 'site_address') {
    $node->getType();
    $field_address = $node->get('field_address')[0];

    $full_address = $field_address->address_line1; //address
    $full_address .= ', ' . $field_address->address_line2; // number address
    //$full_address .= ', ' . $field_address->organization;  // local name
    $full_address .= ' - ' . $field_address->dependent_locality;  // Neighborhood
    $full_address .= ', ' . $field_address->locality; // city
    $full_address .= ' - ' . $field_address->administrative_area; // state
    $full_address .= ', ' . $field_address->postal_code; // cep
    $full_address .= ', ' . $field_address->country_code; // country

    // Set the full address on map field.
    $node->get('field_complete_address')->value = $full_address;

    $address_to_get_coordinates = $field_address->address_line1; //address
    $address_to_get_coordinates .= ' ' . $field_address->address_line2; // number address
    //$address_to_get_coordinates .= ', ' . $field_address->dependent_locality;  // Neighborhood
    $address_to_get_coordinates .= ', ' . $field_address->locality; // city
    $address_to_get_coordinates .= ' - ' . $field_address->administrative_area; // state
    $address_to_get_coordinates .= ', ' . $field_address->postal_code; // cep
    $address_to_get_coordinates .= ', ' . $field_address->country_code; // country

    $url = 'https://nominatim.openstreetmap.org/search?format=json&q=' . urlencode($address_to_get_coordinates);

    $opts = array(
      'http'=>array(
          'user_agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
      )
    );
    $context = stream_context_create($opts);
    $response = file_get_contents($url, false, $context);
    $data = json_decode($response);
    
    if ($data === null) {
      echo "Error decoding JSON response: ";
    } else {
      var_dump($data);
    }

    // Extract the latitude and longitude coordinates from the response
    $lat = $data[0]->lat;
    $lng = $data[0]->lon;

    $node->get('field_coordinates')->value = $lat . ' , ' . $lng;    

  }
}

/**
 * Implements hook_node_access().
 */
// function find_checkin_node_access(NodeInterface $node, $op, AccountInterface $account) {

//   // $current_url = \Drupal::request()->getRequestUri();
//   // $current_url;
//   // // Block access if the user is not authenticated.
//   // if (!$account->isAuthenticated()
//   //   && $current_url != 'user/login'
//   //   && $current_url != '/user/register'
//   //   && $current_url != '/user/password'
//   // ) {
//   //   // Redirect the user to login.
//   //   $response = new RedirectResponse('/user/login');
//   //   $response->send();
//   // }
// }

function find_checkin_form_alter(&$form, &$form_state, $form_id) {

  // Change the comment field to plain text.
  if ($form_id == 'comment_comment_form') {
    $form['comment_body']['widget'][0]['#format'] = 'plain_text';
    $form['comment_body']['widget'][0]['#allowed_formats'] = ['plain_text'];
    $form['comment_body']['widget'][0]['#rows'] = 1;
    unset($form['actions']['preview']);

    // This line enables the Enter key to add a new line in the comment field.
    $form['comment_body']['widget'][0]['#input'] = TRUE;

    // Each time that the user hits Enter one line is add.
    $form['comment_body']['widget'][0]['#attributes']['onkeydown'] = 'if(event.keyCode==13){this.rows += 1;}';

    // Add a validation function to check if the textarea is empty.
    $form['#validate'][] = '_find_checkin_form_validate';
  }

}

function _find_checkin_form_validate($form, &$form_state) {
  $comment_body = $form_state->getValue('comment_body')[0]['value'];
  if (empty($comment_body)) {
    $form_state->setErrorByName('comment_body', t('Please enter a comment before to post.'));
  }
}

/**
 * Implements hook_ENTITY_TYPE_access() for comment entity type.
 */
function find_checkin_comment_access(CommentInterface $comment, $op, AccountInterface $account) {
  if ($op == 'delete' && $comment->getOwnerId() == $account->id()) {
    return AccessResult::allowedIfHasPermission($account, 'delete own comments');
  }
  return AccessResult::neutral();
}

/**
 * Implements hook_comment_view_alter to add the author's name on reply.
*/
function find_checkin_comment_view_alter(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {

  $comment = $build['#comment'];

  if ($entity->getEntityTypeId() == 'comment' && isset($build['#comment'])) {
    // Check if this is a reply comment.
    if ($comment->getParentComment()) {
      // Get the parent comment.
      $parent_comment = $comment->getParentComment();

      // Load the author of the parent comment.
      $parent_author = User::load($parent_comment->getOwnerId());

      // Add author's name on reply.
      $build['#prefix'] = '<div class="parent-comment-wrapper">' .
      '<div class="parent-comment-info">' .
      t('Reply to') .
      '</div>' .
      '<div class="username-info">' .
        $parent_author->getDisplayName() .
      '</div>' .
      '</div>' .
      $build['#prefix'];
    }
  }
 
  // Check if the comment has been edited.
  if ($comment->getChangedTime() != $comment->getCreatedTime()) {

    // Create a DrupalDateTime object from the change timestamp of the comment.
    $change_time = DrupalDateTime::createFromTimestamp($comment->getChangedTime());
    // Format the change time into the desired pattern.
    $formatted_time = $change_time->format('D, m/d/Y - H:i');

    // Add an "EDIT" message to the comment body.
    $build['comment_body'][0]['#prefix'] = '<div class="comment-edit">Modified: ' . $formatted_time . '</div>';
  }
 
}


/**
 * Implements hook_preprocess_comment().
 */
function find_checkin_preprocess_comment(&$variables) {
  $comment = $variables['elements']['#comment'];
  
  // Check if this is a specific comment type and make changes.
  //if ($comment->bundle() == 'comment') {
    // Do something here.

    // // Get the user ID of the comment author.
    // $author_uid = $comment->getOwnerId();

    // // Load the User entity for the comment author.
    // $author = \Drupal\user\Entity\User::load($author_uid);

    // // Check if the author is valid and get the author name.
    // if ($author) {
    //   $author_name = $author->getDisplayName();
    // }

  // Check if this is the comment edit page.
  $route_match = \Drupal::routeMatch();
  if ($route_match->getRouteName() == 'entity.comment.edit_form') {
    // Get the comment ID from the URL parameters.
    $comment_id = $route_match->getParameter('comment');

    // Load the comment entity by ID.
    $comment = \Drupal\comment\Entity\Comment::load($comment_id);

    // Check if the comment entity is valid and add it to the page variables.
    if ($comment) {
      $variables['comment'] = $comment;
    }
  }

  //}
}


// /**
//  * Implements hook_entity_load().
//  */
// function find_checkin_entity_load($entities, $entity_type_id) {
//   if ($entity_type_id === 'comment') {

//     $comment_storage = \Drupal::entityTypeManager()->getStorage('comment');
//     $comment = $comment_storage->load(6);
    
//     if ($comment) {
//       $revisions = $comment_storage->loadMultipleRevisions([$comment_id]);
//       // Do something with the revisions, for example:
//       foreach ($revisions as $revision) {
//         $revision_id = $revision->getRevisionId();
//         $revision_body = $revision->get('comment_body')->getValue()[0]['value'];
//         // etc.
//       }
//     }
//   }
// }



/**
 * Implements hook_form_FORM_ID_alter().
 */
// function find_checkin_form_comment_comment_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {

//   if ($form_id === "comment_comment_form") {
//     // Get the comment entity from the form state.
//     $comment_entity = $form_state->getFormObject()->getEntity();
    
//     // Check if the entity is of the comment type.
//     if ($comment_entity instanceof \Drupal\comment\CommentInterface) {
//       // Do something with the comment entity.
//       $comment_id = $comment_entity->id();

//       $comment_body = $comment_entity->get('comment_body')->value;

//       // Check if the comment has been edited.
//       $changed_time = $comment_entity->getChangedTime();
//       $created_time = $comment_entity->getCreatedTime();
//       $is_edited = ($changed_time > $created_time);

//       // Create a new div element and add the comment body to it.
//       $new_div = [
//         '#type' => 'html_tag',
//         '#tag' => 'div',
//         '#value' => $comment_body,
//       ];

//       // Add the new div element to the $form array.
//       $form['new_div'] = $new_div;

//     }
//   }
// }

// function find_checkin_entity_load($entities, $entity_type_id) {

//   $current_path = \Drupal::service('path.current')->getPath();

//   if (strpos($current_path, '/comment/') !== false &&
//     $entity_type_id === "comment")
//   {
//     // Extract the comment ID from the path.
//     $comment_id = explode('/', $current_path)[2];

//     $comment_storage = \Drupal::entityTypeManager()->getStorage('comment');
//     $comment_entity = $comment_storage->loadByProperties(['cid' => $comment_id]);
//     if (!empty($comment_entity)) {
//       $comment_entity = reset($comment_entity);
//       $comment_body = $comment_entity->get('comment_body')->value;
//     }
//   }
// }

function find_checkin_entity_load($entities, $entity_type_id) {

  $current_path = \Drupal::service('path.current')->getPath();

  if (strpos($current_path, '/comment/') !== false &&
    $entity_type_id === "comment")
  {
    foreach ($entities as $comment_entity) {
      // Check if the comment has been edited.
      $changed_time = $comment_entity->getChangedTime();
      $created_time = $comment_entity->getCreatedTime();
      $is_edited = ($changed_time > $created_time);

      if ($is_edited) {
        // Get the comment body.
        $comment_body = $comment_entity->get('comment_body')->value;

        $comment_output = [
          '#type' => 'html_tag',
          '#tag' => 'div',
          '#attributes' => ['class' => 'breadcrumb__item'],
          '#value' => $comment_body,
        ];
        $comment_render = \Drupal::service('renderer')->renderRoot($comment_output);
        // Output the rendered comment body.
        print $comment_render;        

      }
    }
  }
}
